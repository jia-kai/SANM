#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm

import argparse
import os
import collections
import json
import tempfile

Entry = collections.namedtuple('Entry', ['img_path', 'time', 'iter', 'rms'])

def set_plot_style():
    # see http://www.jesshamrick.com/2016/04/13/reproducible-plots/
    plt.style.use(['seaborn-white', 'seaborn-paper'])
    matplotlib.rcParams.update({
        'font.size': 14,
        'legend.fontsize': 'medium',
        'axes.labelsize': 'large',
        'axes.titlesize': 'medium',
        'xtick.labelsize': 'large',
        'ytick.labelsize': 'large',
    })

def make_time_plot(args, width, xs, ys, xmax):
    """:return: an image of the times"""
    dpi = 96
    fig = plt.figure(figsize=(width / dpi, width * args.plot_hw / dpi),
                     dpi=dpi)
    ax = fig.add_subplot()
    ax.plot(xs, ys, '-o', lw=2, color='#330033', markersize=9,
            markevery=[len(xs) - 1])
    ax.set_xlim(0, xmax * 1.1)
    ax.set_ylim(args.rmin, args.rmax)
    ax.set_yscale('log')
    ax.set_xlabel('Time (seconds)')
    ax.set_ylabel('RMS')
    fig.tight_layout()
    with tempfile.NamedTemporaryFile(suffix='.png') as ftmp:
        fig.savefig(ftmp.name, bbox_inches='tight', transparent=True,
                    dpi=dpi * 1.8)
        plt.close(fig)
        img = cv2.imread(ftmp.name, cv2.IMREAD_COLOR)
        img = cv2.resize(img, (width, int(img.shape[0] / img.shape[1] * width)))
        return 255 - img

def main():
    parser = argparse.ArgumentParser(
        description='create a video from images generated by make_vid.sh',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('-d', '--dir', required=True,
                        help='path to the output directory')
    parser.add_argument('-s', '--time-scale', type=float, default=0.3,
                        help='scale the real solving time')
    parser.add_argument('--rmin', type=float, default=1e-7, help='min rms')
    parser.add_argument('--rmax', type=float, default=1e-2, help='max rms')
    parser.add_argument('--plot-hw', type=float, default=0.5,
                        help='time plot H/W ratio')
    parser.add_argument('--fps', type=int, default=30,
                        help='output video fps')
    parser.add_argument('-o', '--output', required=True,
                        help='video output path')
    args = parser.parse_args()
    set_plot_style()

    entries = []
    with os.scandir(args.dir) as it:
        for ent in it:
            if ent.name.endswith('.png'):
                with open(ent.path[:-3] + 'json') as fin:
                    j = json.load(fin)
                    if j['rms'] >= args.rmin:
                        entries.append(Entry(ent.path, **j))
    entries.sort(key=lambda x: x.time)
    xs = []
    ys = []

    vwriter = None
    tot_frame = int(args.time_scale * entries[-1].time * args.fps)

    for idx, ent in enumerate(tqdm(entries)):
        xs.append(ent.time)
        ys.append(ent.rms)

        this_frame = idx * tot_frame // len(entries)
        next_frame = (idx + 1) * tot_frame // len(entries)
        if this_frame == next_frame:
            continue

        img = cv2.imread(ent.img_path, cv2.IMREAD_COLOR)
        h, w, chl = img.shape
        plot = make_time_plot(args, w, xs, ys, entries[-1].time)
        img = np.concatenate([img, plot], axis=0)
        cv2.putText(img, f'time={ent.time:.2f}s iter={ent.iter}',
                    (10, 50), cv2.FONT_HERSHEY_SIMPLEX,
                    1, (255, 255, 200), 2)
        cv2.putText(img, f'RMS={ent.rms:.2e}',
                    (10, 80), cv2.FONT_HERSHEY_SIMPLEX,
                    .8, (255, 255, 200), 2)
        if vwriter is None:
            vwriter = cv2.VideoWriter(
                args.output,
                cv2.VideoWriter_fourcc(*'mp4v'),
                args.fps,
                (img.shape[1], img.shape[0]))

        for i in range(next_frame - this_frame):
            vwriter.write(img)

    vwriter.release()

if __name__ == '__main__':
    main()
